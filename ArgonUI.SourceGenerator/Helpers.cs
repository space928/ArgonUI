using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace ArgonUI.SourceGenerator;

internal static class Helpers
{
    public static string GetText(this Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.NotApplicable => "",
            Accessibility.Private => "private",
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedAndInternal => "private protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            _ => ""
        };
    }

    public static void EmitFileHeader(IndentedStringBuilder sb, string nameSpace, bool nullable, string[]? includes = null)
    {
        sb.AppendLine("""
            // <auto-generated/>
            /**************************************************|
            | This file is automatically generated by ArgonUI. |
            |**************************************************/

            """);

        if (includes != null)
        {
            foreach (var include in includes)
                sb.AppendLine($"using {include};");
            sb.AppendLine();
        }

        sb.AppendLine($"namespace {nameSpace};");
        sb.AppendLine();

        if (nullable)
        {
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
        }
    }

    public static void PrintDocComment(IndentedStringBuilder sb, string docComment)
    {
        /* Example docComment
<member name="F:ArgonUI.SourceGenerator.Test.ReactiveTest.test4">
    <summary>
    An example property.
    </summary>
</member>
        */

        // Lets be lazy and just strip out the first and last lines (<member> tags)
        // In the future we may want to optimise this to reduce allocations.
        var lines = docComment.Split('\n');
        foreach (var line in lines.Skip(1).Take(lines.Length - 3))
        {
            sb.AppendIndent().Append("/// ").Append(line.TrimStart(' ')).AppendLine();
        }
    }

    public static EquatableArray<T> AsEquatable<T>(this ImmutableArray<T> immutable) => new(immutable);

    public static EquatableDictionary<TKey, EquatableArray<TValue>> ToEquatable<TKey, TValue>(this IEnumerable<IGrouping<TKey, TValue>> grouping)
        where TKey : notnull
    {
        return new(grouping.Select(x => new KeyValuePair<TKey, EquatableArray<TValue>>(x.Key, x.ToImmutableArray().AsEquatable())));
    }

    public static int GetStringHash(this ReadOnlySpan<char> key)
    {
        //return string.GetHashCode(key);

        int hash = unchecked((int)2166136261);
        const int prime = 16777619;

        /*var bytes = MemoryMarshal.AsBytes(key);
        for (int i = 0; i < bytes.Length; i++)
        {
            hash ^= bytes[i];
            hash *= prime;
        }*/

        // FNV Hash, a very simple hash, but in my testing performe equally well in quality to the
        // default hash (the load factor and total number of buckets with links are almost identical),
        // in fact FNV was sometimes even slightly better. And it's always slightly faster.
        int len = key.Length;
#if !NETSTANDARD
        var ints = MemoryMarshal.CreateReadOnlySpan(
#else
        var ints = PolyFill.CreateReadOnlySpan(
#endif
            ref Unsafe.As<char, int>(ref MemoryMarshal.GetReference(key)),
            len << 1);//MemoryMarshal.Cast<char, int>(key);
        int lenInt = len >> 1;
        for (int i = 0; i < lenInt; i++)
        {
            hash ^= ints[i];
            hash *= prime;
        }
        if ((len & 1) == 1)
        {
            hash ^= key[len - 1];
            hash *= prime;
        }

        return hash;
    }
}
